What happens when you initialize a repository? Why do you need to do it?

- It starts that directory as a blank slate for commiting stuff by making a .git thing and giving you the opportunity to commit stuff to it from them on. Here is where the commits to all your tracked files will go down and be stored.  


How is the staging area different from the working directory and the repository? What value do you think it offers? 

- The staging area are the files in the working directory at the state they were added to the commit but could be different from what's in the working dirrectory. If there's a commit it will go to the local reopository.

How can you use the staging area to make sure you have one commit per logical change?

- You can double check to make sure that no files you don't want commited yet aren't included. To take stuff out of the staging area just do git reset <what you want out>.  Then do some git status to make sure things look good and commit.


What are some situations when branches would be helpful in keeping your history organized? How would branches help?

- Branches should be used when I want to kep the main branch stable and want to try new stuff with the codebase or provide a way for other people to try new stuff as well.

How do the diagrams help you visualize the branch structure?

-  You can easilly see different branches relationships to each other and to the master branch. It may explain why some features are not available on certain branches.

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?

-  Merging two branches together attempts to bring any new commits of a branch to the other one while deleting parts that have been deleted. We represent it the way we do to show which it can be easier identified which commits came in where.

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges manually?

- Automatic merging can save time and if there are no conflicts everything should work well together.  Doing merges manually though gives you a chance to really see which version of code you'd like to keep in that branch.  So basically you lose some control going the automatic route but it's quicker.

  
